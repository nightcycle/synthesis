import os
import json
from typing import TypedDict, Optional

SRC_DIR_PATH = "src"
HEADER_WARNING = "-- this script was generated by the build system, please do not make manual edits"

# functions
def camel_to_upper_snake(name: str) -> str:
	if (len(name) == 0):
		return ""
	return "".join(["_" + c.lower() if c.isupper() else c for c in name]).upper()

def camel_to_pascal(name: str) -> str:
	if (len(name) == 0):
		return ""
	return name[0].upper() + name[1:]

def pascal_to_camel(name: str) -> str:
	if (len(name) == 0):
		return ""
	return name[0].lower() + name[1:]

# Classes
class ParameterDefinition(TypedDict):
	name: str
	type: str
	default: str
	description: Optional[str]
	comment: Optional[str]

class FunctionDefinition(TypedDict):
	names: list[str]
	key: str
	parameters: list[ParameterDefinition]
	description: Optional[str]

class ComponentDefinition:
	path: str
	name: str
	display_name: str
	description: str
	functions: list[FunctionDefinition]

	# add constructor
	def __init__(self, path: str):
		with open(path, "r") as file:
			data = json.load(file)
			self.path = os.path.dirname(path)
			self.name = os.path.basename(self.path)
			self.display_name = data["name"]
			self.description = data["description"]
			self.functions = data["functions"]

	def get_header(self, include_source=True, include_translators=True, include_enums=True, include_roact=False, include_react=False) -> str:
		# get number of steps in the path
		steps = len(self.path.split(os.path.sep))
		# repeat the string "Parent" steps time, putting a . in between each one
		package_req_path: str =  ".".join(["Parent"] * steps)

		source_req = 'local Source = require(script.Parent:WaitForChild("ColdFusion"))\n'
		if not include_source:
			source_req = ""

		enum_req = 'local Enums = require(_Package:WaitForChild("Enums"))\n'
		if not include_enums:
			enum_req = ""

		trans_req = 'local Translators = require(_Package:WaitForChild("Translators"))\n'
		if not include_translators:
			trans_req = ""

		roact_rec = 'local Roact = require(_Packages:WaitForChild("Roact"))'
		if not include_roact:
			roact_rec = ""


		react_lua_rec = 'local React = require(_Packages:WaitForChild("React"))\nlocal ReactRoblox = require(_Packages:WaitForChild("ReactRoblox"))'
		if not include_react:
			react_lua_rec = ""

		return f"""--!strict
{HEADER_WARNING}
local _Package = script.{package_req_path}
local _Packages = _Package.Parent
-- Services
-- Packages
local Maid = require(_Packages:WaitForChild("Maid"))
local ColdFusion = require(_Packages:WaitForChild("ColdFusion"))
{roact_rec}
{react_lua_rec}

-- Modules
local Types = require(_Package:WaitForChild("Types"))
local Style = require(_Package:WaitForChild("Style"))
{enum_req}
{trans_req}
{source_req}
-- Types
type Maid = Maid.Maid
type Style = Style.Style
type FontData = Types.FontData
type OptionData = Types.OptionData
type ButtonData = Types.ButtonData
type ImageData = Types.ImageData
type CanBeState<V> = ColdFusion.CanBeState<V>"""

	def write_defaults(self) -> None:
		lines: list[str] = [
			self.get_header(include_source=False, include_translators=False),
			'\nreturn {',
		]

		for func in self.functions:
			for name in func["names"]:
				def_param_values: list[str] = []
				for param in func["parameters"]:
					# print(param)
					# print("\t" + self.name + ":" + name + ":" + param["name"] + " -> " + param["default"])
					if param['default'] != '':
						type_annotation = ""
						if param['default'] == "nil":
							type_annotation = " :: " + param["type"]

						def_param_values.append(camel_to_upper_snake(param['name']) + ' = ' + param['default'] + type_annotation)

				lines += [
					camel_to_upper_snake(name) + " = {",
					",".join(def_param_values),
					"},"
				]
		lines += [
			'}',
		]

		out_path = self.path + "/Defaults.luau"
		with open(out_path, "w") as file:
			file.write("\n".join(lines))

	def write_fusion(self) -> None:
		lines: list[str] = [
			self.get_header(),
			'type FusionCanBeState<V> = Translators.FusionCanBeState<V>\n',
			'-- Constants',
			'local DEFAULTS = require(script.Parent:WaitForChild("Defaults"))',
			'-- Variables',
			'-- References',
			'-- Private Functions',
			'-- Class',
			'local Interface = {}\n',
		]

		for func in self.functions:
			inner_params: list[str] = []

			for param in func["parameters"]:
				inner_params.append(param["name"]+': FusionCanBeState<'+param["type"]+'>')

			for name in func["names"]:
				passed_params: list[str] = []
				for param in func["parameters"]:
					passed_params.append("convert("+param["name"]+", DEFAULTS."+camel_to_upper_snake(name)+"."+camel_to_upper_snake(param["name"])+")")

				function_lines = [
					f'\nfunction Interface.{name}(',
						",".join(inner_params),
						'): GuiObject',
						'local maid = Maid.new()',
						'local _fuse = ColdFusion.fuse(maid)',
						'local function convert<V>(value: FusionCanBeState<V>, default: V): CanBeState<V>',
							'return Translators.Fusion.toColdFusion(maid, _fuse, value, default)',
						'end',
						f'local inst = Source.{name}(',
						",".join(passed_params),
						')',
						'maid:GiveTask(inst.Destroying:Connect(function()',
							'maid:Destroy()',
						'end))',
						'return inst',
					'end',
				]

				lines += function_lines

		lines += [
			'\nreturn Interface',
		]

		out_path = self.path + "/Fusion.luau"
		with open(out_path, "w") as file:
			file.write("\n".join(lines))

	def write_roact(self, is_react_lua: bool=False) -> None:
		lines: list[str] = [
			self.get_header(include_roact=not is_react_lua, include_react=is_react_lua, include_translators=False, include_enums=False),
			'-- Constants',
			'local DEFAULTS = require(script.Parent:WaitForChild("Defaults"))',
			'-- Variables',
			'-- References',
			'-- Private Functions',
			'-- Class',
			'local Interface = {}\n',
		]

		framework_name = "Roact"
		secondary_framework_name = "Roact"
		mount_func_name = "didMount"
		portal_ref = "Roact.Portal"
		if is_react_lua:
			framework_name = "React"
			mount_func_name = "componentDidMount"
			portal_ref = "ReactRoblox.createPortal"
		
		for func in self.functions:
			for name in func["names"]:
				component_name = camel_to_pascal(name)+camel_to_pascal(self.path.replace("\\", "").replace("srcComponent", ""))

				lines += [
					"\ndo",
					f'local {component_name} = {framework_name}.Component:extend("{component_name}")',
					component_name + ".defaultProps = {",
				]
				for param in func["parameters"]:
					lines.append(f'{param["name"]} = DEFAULTS.{camel_to_upper_snake(name)}.{camel_to_upper_snake(param["name"])},')
				lines += [
					'}',
					'function '+component_name+':init(initialProps: {[string]: unknown})',
						'self._maid = Maid.new()',
						'local _fuse = ColdFusion.fuse(self._maid)',
						'local _Value = _fuse.Value',
						'self._internalStates = {',
				]

				for param in func["parameters"]:
					lines.append(f'{param["name"]} = _Value(self.defaultProps.{param["name"]}),')
				lines += [
					'}',
					'table.freeze(self._internalStates)',

					'for k, v in pairs(initialProps) do',
						'if self._internalStates[k] then',
							'self._internalStates[k]:Set(v)',
						'end',
					'end',

					f'self._instance = Source.{name}(',
				]

				param_lines: list[str] = []
				for param in func["parameters"]:
					param_lines.append(f'self._internalStates.{param["name"]}')

				lines += [
					",".join(param_lines),
					')',
				'end',
				'\nfunction '+component_name+':render()',
					'local props = {',
						'target = self._instance',
					'}',
					'for k, v in pairs(self.props) do',
						'if self.props[k] ~= v then',
							'if self._internalStates[k] then',
								'if v == nil then',
									'v = self.defaultProps[k]',
								'end',
								'self._internalStates[k]:Set(v)',
							'else',
								'props[k] = v',
							'end',
						'end',
					'end',
					f'return {framework_name}.createElement({portal_ref}, props)',
				'end',

				'function '+component_name+f':{mount_func_name}()',
					'for k, v in pairs(self) do',
						'if typeof(v) == "table" then',
							'if v["virtualNode"] then',
								'if self._instance.Parent ~= v["virtualNode"]["hostParent"] then',
									'self._instance.Parent = v["virtualNode"]["hostParent"]',
								'end',
								'break',
							'end',
						'end',
					'end',
				'end',

				'function '+component_name+':willUnmount()',
					'self._maid:Destroy()',
					'self._instance:Destroy()',
				'end',

				'Interface.'+camel_to_pascal(name)+' = '+component_name,
				'end',
			]

		lines.append('\nreturn Interface')
		out_path = self.path + f"/{framework_name}.luau"
		
		with open(out_path, "w") as file:
			file.write("\n".join(lines))

	def write_wrapper(self) -> None:
		lines: list[str] = [
			self.get_header(),
			'type Wrapper<BaseInstance, Definition, ClassName> = Translators.Wrapper<BaseInstance, Definition, ClassName>\n',
		]

		for func in self.functions:
			key: str = camel_to_pascal(func['key'])
			type_lines: list[str] = [
				f'\nexport type {key}{self.name}WrapperDefinition = '+'{',

			]
			for param in func["parameters"]:
				type_lines.append(camel_to_pascal(param["name"]) + ": " + param["type"]+",")


			type_lines += [
				'}',
				f'export type {key}{self.name}Wrapper = Wrapper<GuiObject, {key}{self.name}WrapperDefinition, "{key}{self.name}">',

			]

			lines += type_lines


		lines += [
			'-- Constants',
			'local DEFAULTS = require(script.Parent:WaitForChild("Defaults"))',
			'-- Variables',
			'-- References',
			'-- Private Functions',
			'-- Interface',
			'local Interface = {}',
		]

		for func in self.functions:
			# key = func['key']
			# if key != "":
			for name in func["names"]:

				lines += [
					f'\nfunction Interface.{name}(): {camel_to_pascal(key)}{self.name}Wrapper',
						'local maid = Maid.new()',
						'local _fuse = ColdFusion.fuse(maid)',
						'local _Value = _fuse.Value',

						'local definition = {',
				]
				for param in func["parameters"]:
					lines.append(f'{camel_to_pascal(param["name"])} = _Value('+param["default"]+'),')

				lines += [
					'}',
					'local defaults: {[string]: unknown?} = {'
				]
				for param in func["parameters"]:
					lines.append(f'{param['name']} = DEFAULTS.{camel_to_upper_snake(name)}.{camel_to_upper_snake(param['name'])},')

				lines += [
						'}',
						f'local inst: GuiObject = Source.{name}(',
				]
				def_params = []
				for param in func["parameters"]:
					def_params.append(f'definition.{camel_to_pascal(param["name"])}')

				lines += [
						",".join(def_params),
						')',

						'maid:GiveTask(inst.Destroying:Connect(function()',
							'maid:Destroy()',
						'end))',

						f'local wrapper, cleanUp = Translators.ColdFusion.toWrapper("{camel_to_pascal(key)}{self.name}", inst, definition, defaults)',
						'maid:GiveTask(cleanUp)',

						'return wrapper',
					'end',
				]

		lines += [
			'\nreturn Interface',
		]

		out_path = self.path + "/Wrapper.luau"
		with open(out_path, "w") as file:
			file.write("\n".join(lines))

	def write_init(self) -> None:
		lines: list[str] = [
			'--!strict',
			HEADER_WARNING,
			'return {'
				'ColdFusion = require(script:WaitForChild("ColdFusion")),',
				'Fusion = require(script:WaitForChild("Fusion")),',
				'Wrapper = require(script:WaitForChild("Wrapper")),',
				'Roact = require(script:WaitForChild("Roact")),',
				'React = require(script:WaitForChild("React")),',
			'}'
		]

		out_path = self.path + "/init.luau"
		with open(out_path, mode="w") as file:
			file.write("\n".join(lines))

	def write_md(self) -> None:
		lines: list[str] = [
			f"# {self.display_name}\n",
		]
		if (os.path.exists(self.path + "/preview.gif")):
			lines.append(f"![Preview](preview.gif)\n")
		lines.append(self.description)

		lines += [
			"# Constructors\n"
		]
		lines.append("")

		for func in self.functions:
			lines.append(f"## {' / '.join(func['names'])}")
			if func['key'] == "":
				lines.append("This function is a native constructor, with verbosity allowing for control over every configurable property at the cost of a less convenient calling.")
			elif func['key'] == "styled":
				lines.append("This function is a style constructor, utilizing the \"Style\" type to reduce the number of parameters required for implementation.")

			if "description" in func:
				lines.append(func['description'])

			lines.append("\n### Parameters")

			for param in func['parameters']:
				description = ""
				if "description" in param:
					description = " = " + param["description"]
				lines.append(f"- **{param['name']}**: {param['type']}{description}")
			lines.append("")

			lines.append("\n### Usage")

			fusion_lines: list[str] = [
				'\n**Fusion**',
				'```luau',
			]
			fusion_param_line: list[str] = []
			fusion_index = 0
			for param in func['parameters']:
				fusion_index += 1
				comment = ""
				if "comment" in param:
					comment = f" -- {param['comment']}"

				if fusion_index % 2 == 0:
					fusion_param_line.append("\t"+param["name"]+"")
					fusion_lines.append(f'local {param["name"]}: {param["type"]} = {param["default"]}{comment}')
				else:
					fusion_param_line.append("\t"+param["name"]+"State")
					fusion_lines.append(f'local {param["name"]}State: Fusion.Value<{param["type"]}> = Value({param["default"]}){comment}')

			fusion_lines += [
				"",
				f'local {pascal_to_camel(self.name)}: GuiObject = {self.path.replace('src', 'Synthetic').replace("\\", ".")}.Fusion.{func['names'][0]}(',
			]
			fusion_lines.append(",\n".join(fusion_param_line))
			fusion_lines.append(")\n```")

			vanilla_lines: list[str] = [
				'\n**No Framework**',
				'```luau',
			]
			vanilla_modifications: list[str] = []
			for param in func['parameters']:
				comment = ""
				if "comment" in param:
					comment = f" -- {param['comment']}"

				vanilla_lines.append(f'local {param["name"]}: {param["type"]} = {param["default"]}{comment}')
				vanilla_modifications.append(f'{pascal_to_camel(self.name)}.{camel_to_pascal(param["name"])} = {param["name"]}')

			vanilla_lines += [
				f'\nlocal {pascal_to_camel(self.name)} = {self.path.replace('src', 'Synthetic').replace("\\", ".")}.Wrapper.{func['names'][0]}()',
			] + vanilla_modifications + [
				'```',
			]

			def write_roact_md(is_react_lua: bool=False) -> None:
				package_name = "Roact"
				if is_react_lua:
					package_name = "React"
				roact_lines: list[str] = [
					f'\n**{package_name}**',
					'```luau',
					f'local {pascal_to_camel(self.name)} = {package_name}.createElement(Module.{package_name}.{camel_to_pascal(func["names"][0])}, '+'{'
				]
				for param in func['parameters']:
					comment = ""
					if "comment" in param:
						comment = f" -- {param['comment']}"

					roact_lines.append(f'\t{param["name"]} = {param["default"]},{comment}')
				
				if is_react_lua:
					roact_lines += [
						'})\n',
						f'local root = {package_name}Roblox.createRoot(parent)',
						f'root:render({pascal_to_camel(self.name)})',
						'```'
					]
				else:
					roact_lines += [
						'})\n',
						f'{package_name}.mount({pascal_to_camel(self.name)}, parent)',
						'```'
					]
				return roact_lines

			lines += vanilla_lines
			lines += fusion_lines
			lines += write_roact_md(is_react_lua=False)
			# lines += write_roact_md(is_react_lua=True)


		out_path = self.path + "/README.md"
		with open(out_path, mode="w") as file:
			file.write("\n".join(lines))

	def write_all(self) -> None:
		self.write_defaults()
		self.write_fusion()
		self.write_roact()
		self.write_roact(is_react_lua=True)
		self.write_wrapper()
		self.write_init()
		self.write_md()

# iterate through tree under directory SRC_DIR_PATH, looking for files named "definition.json", then print the path
component_definitions: list[ComponentDefinition] = []

for root, dirs, files in os.walk(SRC_DIR_PATH):
	for file in files:
		if file == "definition.json":
			component_definitions.append(ComponentDefinition(os.path.join(root, file)))


for definition in component_definitions:
	print(definition.path)
	definition.write_all()

